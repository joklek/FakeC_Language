package com.joklek.fakec.generator;

import org.apache.commons.lang3.StringUtils;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

import java.io.*;
import java.util.Arrays;
import java.util.List;

/**
 * Generates AST nodes
 */
@Mojo(name = "generateAST", defaultPhase = LifecyclePhase.GENERATE_SOURCES)
public class SourceGeneratorMojo extends AbstractMojo {

    @Parameter(required = true, defaultValue = "${project.basedir}/src/main/resources/ASTResources")
    private String sourceDirectory;

    @Parameter(required = true, defaultValue = "${project.build.directory}/generated-sources/java")
    private String targetDirectory;

    @Parameter(required = true, defaultValue = "com.joklek.fakec.parsing.ast")
    private String currentPackage;

    @Parameter
    private List<String> resourceFiles;

    @Parameter(defaultValue = "${project}")
    private MavenProject project;

    public void execute()
    {
        for(String resource: resourceFiles) {
            getLog().info( sourceDirectory + "/" + resource + ".txt");
            if (resourceFiles.isEmpty()) {
                System.err.println("No resource files given");
                System.exit(1);
            }
            String outputDir = targetDirectory + "/" + currentPackage.replace('.', '/');
            List<String> readFile = null;

            String fileName = resource + ".txt";
            try {
                readFile = Arrays.asList(readFile(new File(sourceDirectory, fileName)).split("\n"));
            } catch (IOException e) {
                System.err.println(String.format("File %s, could not be found", fileName));
                e.printStackTrace();
                System.exit(1);
            }
            try {
                defineAst(outputDir, resource, readFile);
            } catch (IOException e) {
                System.err.println(String.format("File %s.java, could not be created", fileName));
                e.printStackTrace();
                System.exit(1);
            }
        }
        project.addCompileSourceRoot(targetDirectory);
    }

    private String readFile(File file) throws IOException {
        try(BufferedReader br = new BufferedReader(new FileReader(file))) {
            StringBuilder sb = new StringBuilder();
            String line = br.readLine();

            while (line != null) {
                sb.append(line);
                sb.append(System.lineSeparator());
                line = br.readLine();
            }
            return sb.toString();
        }
    }

    private void defineAst(String outputDir, String baseName, List<String> types) throws IOException {
        File file = new File(outputDir, baseName + ".java");
        if(!file.exists()) {
            file.getParentFile().mkdirs();
            file.createNewFile();
        }

        PrintWriter writer = new PrintWriter(file, "UTF-8");

        writer.println("/*This code is autogenerated for FakeC language*/");
        writer.println(String.format("package %s;", currentPackage));
        writer.println();
        writer.println("import java.util.List;");
        writer.println("import java.util.Map;");
        writer.println("import com.joklek.fakec.tokens.Token;");
        writer.println("import com.joklek.fakec.tokens.TokenType;");
        writer.println();
        writer.println(String.format("public abstract class %s {", baseName));

        defineVisitor(writer, baseName, types);

        for (String type : types) {
            String[] splitType = type.split(":");
            String className = splitType[0].trim();
            String fields = splitType[1].trim();
            writer.println();
            defineType(writer, baseName, className, fields);
        }

        // The base accept() method.
        writer.println();
        writer.println("  public abstract <R> R accept(Visitor<R> visitor);");

        writer.println("}");
        writer.close();
    }

    private void defineVisitor(PrintWriter writer, String baseName, List<String> types) {
            writer.println("  public interface Visitor<R> {");
            for (String type : types) {
                String typeName = type.split(":")[0].trim();
                writer.println(String.format("    R visit%s%s (%s %s);", typeName, baseName, typeName, baseName.toLowerCase()));
            }
            writer.println("  }");
        }

    private void defineType(PrintWriter writer, String baseName, String className, String fieldList) {
        writer.println(String.format("  public static class %s extends %s {", className, baseName));
        writer.println();

        String[] fields = fieldList.split("; ");

        for(int i = 0; i < fields.length; i++) {
            fields[i] = fields[i].trim();
        }

        defineFields(writer, fields);
        defineConstructor(writer, className, fieldList.replace(';', ','), fields);
        defineGetters(writer, fields);

        defineAccept(writer, baseName, className);

        writer.println("  }");
    }

    private void defineFields(PrintWriter writer, String[] fields) {
        for (String field : fields) {
            writer.println(String.format("    private final %s;", field));
        }
        writer.println();
    }

    private void defineConstructor(PrintWriter writer, String className, String fieldList, String[] fields) {
        writer.println(String.format("    public %s(%s) {", className, fieldList));

        // Store parameters in fields.
        for (String field : fields) {
            String name = field.split(" ")[1];
            writer.println(String.format("      this.%s = %s;", name, name));
        }
        writer.println("    }");
        writer.println();
    }

    private void defineGetters(PrintWriter writer, String[] fields) {
        for (String field : fields) {
            String[] typeAndName = field.split(" ");
            writer.println(String.format("    public %s get%s() {", typeAndName[0].trim(), StringUtils.capitalize(typeAndName[1].trim())));
            writer.println(String.format("      return %s;", typeAndName[1].trim()));
            writer.println("    }");
            writer.println();
        }
    }

    private void defineAccept(PrintWriter writer, String baseName, String className) {
        writer.println("    public <R> R accept(Visitor<R> visitor) {");
        writer.println(String.format("      return visitor.visit%s%s(this);", className, baseName));
        writer.println("    }");
    }
}
